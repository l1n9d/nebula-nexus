from datetime import datetime
from typing import List, Optional, Union
from uuid import UUID

from sqlalchemy import func, select
from sqlalchemy.orm import Session
from src.models.paper import Paper
from src.schemas.arxiv.paper import PaperCreate as ArxivPaperCreate
from src.schemas.pubmed.paper import PaperCreate as PubMedPaperCreate


class PaperRepository:
    def __init__(self, session: Session):
        self.session = session

    def create(self, paper: Union[ArxivPaperCreate, PubMedPaperCreate]) -> Paper:
        db_paper = Paper(**paper.model_dump())
        self.session.add(db_paper)
        self.session.commit()
        self.session.refresh(db_paper)
        return db_paper

    def get_by_arxiv_id(self, arxiv_id: str) -> Optional[Paper]:
        """Get paper by arXiv ID (for backward compatibility)."""
        stmt = select(Paper).where(Paper.arxiv_id == arxiv_id)
        return self.session.scalar(stmt)

    def get_by_pmid(self, pmid: str) -> Optional[Paper]:
        """Get paper by PubMed ID."""
        stmt = select(Paper).where(Paper.pmid == pmid)
        return self.session.scalar(stmt)

    def get_by_paper_id(self, paper_id: str) -> Optional[Paper]:
        """Get paper by either PMID or arXiv ID."""
        # Try PMID first
        paper = self.get_by_pmid(paper_id)
        if paper:
            return paper
        # Fallback to arXiv ID
        return self.get_by_arxiv_id(paper_id)

    def get_by_id(self, paper_id: UUID) -> Optional[Paper]:
        """Get paper by UUID."""
        stmt = select(Paper).where(Paper.id == paper_id)
        return self.session.scalar(stmt)

    def get_all(self, limit: int = 100, offset: int = 0) -> List[Paper]:
        stmt = select(Paper).order_by(Paper.published_date.desc()).limit(limit).offset(offset)
        return list(self.session.scalars(stmt))

    def get_count(self) -> int:
        stmt = select(func.count(Paper.id))
        return self.session.scalar(stmt) or 0

    def get_processed_papers(self, limit: int = 100, offset: int = 0) -> List[Paper]:
        """Get papers that have been successfully processed with content."""
        stmt = (
            select(Paper)
            .where(Paper.content_processed == True)
            .order_by(Paper.content_processing_date.desc())
            .limit(limit)
            .offset(offset)
        )
        return list(self.session.scalars(stmt))

    def get_unprocessed_papers(self, limit: int = 100, offset: int = 0) -> List[Paper]:
        """Get papers that haven't been processed for content yet."""
        stmt = select(Paper).where(Paper.content_processed == False).order_by(Paper.published_date.desc()).limit(limit).offset(offset)
        return list(self.session.scalars(stmt))

    def get_papers_with_raw_text(self, limit: int = 100, offset: int = 0) -> List[Paper]:
        """Get papers that have raw text content stored."""
        stmt = select(Paper).where(Paper.raw_text != None).order_by(Paper.content_processing_date.desc()).limit(limit).offset(offset)
        return list(self.session.scalars(stmt))

    def get_processing_stats(self) -> dict:
        """Get statistics about content processing status."""
        total_papers = self.get_count()

        # Count processed papers
        processed_stmt = select(func.count(Paper.id)).where(Paper.content_processed == True)
        processed_papers = self.session.scalar(processed_stmt) or 0

        # Count papers with text
        text_stmt = select(func.count(Paper.id)).where(Paper.raw_text != None)
        papers_with_text = self.session.scalar(text_stmt) or 0

        return {
            "total_papers": total_papers,
            "processed_papers": processed_papers,
            "papers_with_text": papers_with_text,
            "processing_rate": (processed_papers / total_papers * 100) if total_papers > 0 else 0,
            "text_extraction_rate": (papers_with_text / processed_papers * 100) if processed_papers > 0 else 0,
        }

    def update(self, paper: Paper) -> Paper:
        self.session.add(paper)
        self.session.commit()
        self.session.refresh(paper)
        return paper

    def upsert(self, paper_create: Union[ArxivPaperCreate, PubMedPaperCreate]) -> Paper:
        """Upsert paper - supports both PubMed and arXiv papers."""
        # Check if paper already exists
        existing_paper = None
        
        # Try to find by PMID if it's a PubMed paper
        if hasattr(paper_create, 'pmid') and paper_create.pmid:
            existing_paper = self.get_by_pmid(paper_create.pmid)
        
        # Try to find by arXiv ID if it's an arXiv paper
        if not existing_paper and hasattr(paper_create, 'arxiv_id') and paper_create.arxiv_id:
            existing_paper = self.get_by_arxiv_id(paper_create.arxiv_id)
        
        if existing_paper:
            # Update existing paper with new content
            for key, value in paper_create.model_dump(exclude_unset=True).items():
                setattr(existing_paper, key, value)
            return self.update(existing_paper)
        else:
            # Create new paper
            return self.create(paper_create)
